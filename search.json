[{"title":"力扣刷题2022","url":"/2023/03/29/力扣刷题2022/","content":"\n去年找实习的时候曾短暂地刷过一段时间题，并且简单地整理了一下这些对应部分的题解。\n\n<!--more-->\n\n\n\n#### 1. [1805. 字符串中不同整数的数目](https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/)\n\n代码：\n\n16ms\n\n```java\npublic int numDifferentIntegers(String word) {\n    word = word + 'a';\n    ArrayList<String> ints = new ArrayList<>();\n    int index = 0;\n    String temp = \"\";\n\n\n    while(index <word.length()){\n        if(word.charAt(index) >= '0' && word.charAt(index) <= '9'){\n            temp += word.charAt(index);\n        }\n        else{\n            if(temp.equals(\"\")){\n                index++;\n                continue;\n            }\n            temp = temp.replaceFirst(\"^0*\", \"\");\n            if(!ints.contains(temp)){\n                ints.add(temp);\n            }\n            temp = \"\";\n        }\n        index++;\n\n    }\n\n    return ints.size();\n}\n```\n\n思路：将字符串形式的数字存入ArrayList，通过ArrayList大小来统计数量\n\n注意点\n\n1. 没考虑相同数字的情况（利用正则表达式去掉数字前多余的0）\n2. 没考虑数字大小超出int范围（存储字符串而非int数字）\n3. 使用 Spring ，str += ‘a’的运行效率明显低于使用SpringBuffer和SpringBuilder\n4. equals和length判断字符串是否为空在这题里没有明显区别\n\n\n\n所见最优做法\n\n5ms：\n\n```java\npublic int numDifferentIntegers(String word) {\n    String[] words = word.split(\"[a-z]+\");\n    Set<String> set = new HashSet<>();\n    for(int i=0;i<words.length;i++)\n    {\n        if(words[i].length()==0) continue;\n        int j =0;\n        while (words[i].charAt(j)=='0'&&j<words[i].length()-1){\n            j++;\n        }\n        set.add(words[i].substring(j));\n    }\n    return set.size();\n}\n```\n\nfeature：\n\n* 用正则表达式直接切割字符串\n* 用集合排除重复\n* substring效率并不算太低（因为必须要用到这个字符串，而非中间变量）（比正则高）\n* split效率较低\n\n\n\n\n\n1ms：\n\n```java\n    public int numDifferentIntegers(String word) {\n        char[] nums = word.toCharArray();\n        HashSet<String> set = new HashSet();\n        for(int i = 0;i < nums.length;i++){\n            if(nums[i] - '0' <= 9 && nums[i] - '0' >= 0){\n                //用一个left记录左边的位置，当左边的字符是 '0' 时，更新i，left\n                int left = i;\n                while(i < nums.length && nums[left] == '0'){\n                    left++;\n                    i++; \n                }\n                //遍历到的元素是数字时，i++\n                while(i < nums.length && nums[i] - '0' >= 0 && nums[i] - '0' <= 9){\n                    i++;\n                }\n                //将子字符串保存下来，添加到HashSet中\n                String s = word.substring(left,i);\n                set.add(s);\n            }\n        }\n        return set.size();\n    }\n```\n\n\n\n\n\n#### 2. [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)\n\n16ms，99.95% \n\n40.1MB，78.12%\n\n```java\nimport java.util.ArrayList;\n\nclass MinStack {\n    ArrayList<Integer> stack;\n    ArrayList<Integer> mins;\n    int min;\n    int top;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        stack = new ArrayList<>();\n        mins = new ArrayList<>();\n        min = Integer.MAX_VALUE;\n        top = -1;\n\n\n\n    }\n\n    public void push(int x) {\n        stack.add(x);\n        min = Integer.min(min,x);\n        mins.add(min);\n        top++;\n//        System.out.println(\"push: \" + x);\n\n    }\n\n    public void pop() {\n//        System.out.println(\"pop\");\n//        System.out.println(\"value:\" + stack.get(top));\n        stack.remove(top);\n        mins.remove(top);\n        top--;\n        if(top>=0){\n            min = mins.get(top);\n        }\n        else{\n            min = Integer.MAX_VALUE;\n        }\n//        System.out.println(\"top: \" + top);\n    }\n\n    public int top() {\n//        System.out.println(\"top\");\n//        System.out.print(\"top: \" + top);\n//        System.out.println(\", value:\" + stack.get(top));\n        return stack.get(top);\n\n\n    }\n\n    public int min() {\n//        System.out.println(\"min\");\n//        System.out.print(\"top: \" + top);\n//        System.out.println(\", value:\" + mins.get(top));\n        return mins.get(top);\n\n    }\n}\n```\n\n思路：\n\n既然要求min，pop，push时间复杂度都是O（1）,那就用空间换时间，定义一个mins数组，存储目前为止的最小值。\n\n注意点：\n\n* 一开始使用int数组表示栈，可能会浪费空间，改用ArrayList；\n* min初始化应该使用Integer.MAX_VALUE，确保一定是合适的；\n* push和pop时注意同步更新mins;\n* min表示目前为止整个栈的最小值，所以当pop时注意更新，和mins[top]值一致。\n\n\n\n其他思路：\n\n1. B栈为非严格降序栈，则最小值为B栈栈顶元素（占用空间可以减少）\n\n2. 在不占用额外空间的情况下，存差值，即原元素-当前（不包括自己）最小值\n\n   * 例如 原元素序列： 2 0 -2 6\n   * 则存入的为         ： 2 -2  -2 8\n   * ​             当前最小值2 2 0 -2\n\n   pop时，若栈顶为负，说明当前栈顶的数是原来的最小值，则原来的值为当前最小值，当前最小值应更新为当前最小值-栈顶的数\n\n   若栈顶为正数，说明当前位置原来的数比当前最小值大，所以原来的值为当前最小值+栈顶的数，最小值为当前最小值。\n\n   （未使用额外空间）\n\n   \n\n#### 3. [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)\n\n\n\n```java\nclass CQueue {\n    Stack<Integer> stack = new Stack<>();\n    Stack<Integer> assistStack = new Stack<>();\n\n    public CQueue() {\n\n    }\n\n    public void appendTail(int value) {\n        if(!assistStack.empty()){\n            while(!assistStack.empty()){\n                stack.push(assistStack.pop());\n            }\n        }\n\n        stack.push(value);\n\n\n    }\n\n    public int deleteHead() {\n        if(!stack.empty()){\n            while(!stack.empty()){\n                assistStack.push(stack.pop());\n            }\n        }\n        if(assistStack.empty()){\n            return -1;\n        }\n        return assistStack.pop();\n\n    }\n}\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.appendTail(value);\n * int param_2 = obj.deleteHead();\n */\n```\n\n思路：\n\n1. 两个栈，出的时候将A栈内容弹出到B栈，返回B栈最顶端元素，如果要入栈，则将B元素转至A，再入栈。\n2. 中规中矩，但是速度很慢，因为Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了\n3. 可以考虑用LinkList代替stack\n\n\n\n#### 4. [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\n\n0ms，100%\n\n39.1MB，33%\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        int size = 0;\n        ListNode temp = head;\n        while(temp!=null){\n            size++;\n            temp = temp.next;\n        }\n        int[] result = new int[size];\n        for(int i=0;i<size;i++){\n            result[size-i-1] = head.val;\n            head = head.next;\n        }\n        return result;\n    }\n}\n```\n\n思路：\n\n一开始打算使用arraylist存储元素，后来发现没必要，直接遍历即可得到size，然后倒序存入即可。\n\n\n\n也可使用ArrayList，往前插入，这样可以减少一次遍历。\n\n#### 5. [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)\n\n0ms，100%\n\n38MB， 85.51%\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null){\n            return null;\n        }\n        \n        int size = 1;\n        ListNode temp = head;\n        while(temp.next!=null){\n            size++;\n            temp = temp.next;\n        }\n        int[] result = new int[size];\n        for(int i=0;i<size;i++){\n            result[size-i-1] = head.val;\n            head = head.next;\n        }\n        int index=0;\n        ListNode newHead = new ListNode(result[index]);\n        ListNode indexNode = newHead;\n        index++;\n        while(index<size){\n            temp = new ListNode(result[index]);\n            indexNode.next = temp;\n            index++;\n            indexNode = indexNode.next;\n        }\n        \n        return newHead;\n\n    }\n}\n```\n\n思路：\n\n沿用上一题代码，保存逆序的值，然后重新构建一个链表\n\n\n\n思路二：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null){\n            return head;\n        }\n        ListNode pre = head;\n        ListNode cur = head.next;\n        ListNode next = null;\n        pre.next = null;\n        while(cur != null){\n            next = cur.next;\n            cur.next = pre;\n\n            pre = cur;\n            cur = next;\n\n        }\n        return pre;\n\n    }\n}\n```\n\n0ms，100%\n\n上一种做法引入了别的数据结构，所以不算是很好，这一种用三指针的方式实现链表反转\n\n#### 6. [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n\n5ms，6.11%\n\n37.9MB，78.52%\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n                if(head==null){\n            return null;\n        }\n        Node temp = head;\n        Node newHead = new Node(temp.val);\n        Node newTemp = newHead;\n        while(temp.next != null){\n            temp = temp.next;\n            newTemp.next=new Node(temp.val);\n            newTemp = newTemp.next;\n        }\n        \n        temp = head;\n\n        newTemp = newHead;\n        \n        while(temp!=null){\n            Node temp2 =head;\n            Node newTemp2 = newHead;\n            if(temp.random!=null){\n                while(temp.random != temp2){\n                    temp2 = temp2.next;\n                    newTemp2 = newTemp2.next;\n                }\n                newTemp.random = newTemp2;\n            }\n\n            temp = temp.next;\n            newTemp = newTemp.next;\n            \n        }\n        return newHead;\n        \n    }\n}\n```\n\n思路：\n\n没有想到简单的方法，直接遍历求解\n\n其他思路：\n\n回溯 + 哈希表\n\n思路及算法\n\n本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。\n\n具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。\n\n在实际代码中，我们需要特别判断给定节点为空节点的情况。\n\n```java\nclass Solution {\n    Map<Node, Node> cachedNode = new HashMap<Node, Node>();\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        if (!cachedNode.containsKey(head)) {\n            Node headNew = new Node(head.val);\n            cachedNode.put(head, headNew);\n            headNew.next = copyRandomList(head.next);\n            headNew.random = copyRandomList(head.random);\n        }\n        return cachedNode.get(head);\n    }\n}\n```\n\n\n\n\n\n**鸽了好久之后又来更新了**\n\n\n\n\n\n#### 7. [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix.length == 0){\n            return false;\n        }\n\n        for(int i = 0, j = matrix[0].length - 1; i < matrix.length && j >= 0; ){\n            if(matrix[i][j] > target){\n                j--;\n            }\n            else if(matrix[i][j] < target){\n                i++;\n            }\n            else{\n                return true;\n            }\n        }\n        \n        return false;\n    }\n        \n    \n}\n```\n\n主要思路：抓住每行递增，每列递增的特点，每个矩阵右上角的数是每行的最大值，每列的最小值，所以用右上角的值和target比较，从右上角比较到左下角，就可以得到结果了！复杂度O(n)\n\n用时 100%\n\n\n\n#### 8. [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder res = new StringBuilder();\n        for(int i = 0;i < s.length(); i++){\n            if(s.charAt(i) == ' '){\n                res.append(\"%20\");\n            }\n            else{\n                res.append(s.charAt(i));\n            }\n        }\n        return res.toString();\n\n    }\n}\n```\n\n遍历，遇到空格填上%20，否则就加上原字符。\n\n使用StringBuilder原因：StringBuilder不定长，且效率较高\n\n用时 100%\n\n\n\n#### 9. [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\n我的题解\n\n```java\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder,inorder,0,preorder.length-1,0,inorder.length-1);\n\n    }\n\n\n    public TreeNode buildTree(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){\n        if(preStart == preEnd){\n            return new TreeNode(preorder[preStart]);\n        }\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder,inorder,0,preorder.length-1,0,inorder.length-1);\n\n\n    }\n\n\n    public TreeNode buildTree(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){\n        if(preStart == preEnd){\n            return new TreeNode(preorder[preStart]);\n        }\n        int val = preorder[preStart];\n        int index;\n        for(index = inStart;index <= inEnd;index++){\n            if(inorder[index] == val){\n                break;\n            }\n        }\n        int leftLength = index - inStart;\n        int rightLength = inEnd - index;\n        TreeNode node = new TreeNode(val);\n        node.left = buildTree(preorder,inorder,preStart+1,preStart+leftLength,inStart,inStart+leftLength - 1);\n        node.right = buildTree(preorder,inorder,preStart+leftLength+1,preEnd, index+1,inEnd);\n        return node;\n    }\n        int index;\n        for(index = inStart;index <= inEnd;index++){\n            if(inorder[index] == val){\n                break;\n            }\n        }\n        int leftLength = index - inStart;\n        int rightLength = inEnd - index;\n        TreeNode node = new TreeNode(val);\n        node.left = buildTree(preorder,inorder,preStart+1,preStart+leftLength,inStart,inStart+leftLength - 1);\n        node.right = buildTree(preorder,inorder,preStart+leftLength+1,preEnd, index+1,inEnd);\n        return node;\n    }\n```\n\n\n\n超过 37%\n\n主要存在的问题：\n\n1. 直接写没有提示的时候会搞错一些常用函数/字段，比如数组获取长度是用.length，字段；字符串获取长度是用.length() 函数\n2. ​        int val = preorder[preStart];直接写成了int val = preorder[0];，递归中不应该出现很多魔数\n\n\n\n较好的题解：\n\n```java\nclass Solution {\n    private Map<Integer, Integer> indexMap;\n\n    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {\n        if (preorder_left > preorder_right) {\n            return null;\n        }\n\n        // 前序遍历中的第一个节点就是根节点\n        int preorder_root = preorder_left;\n        // 在中序遍历中定位根节点\n        int inorder_root = indexMap.get(preorder[preorder_root]);\n        \n        // 先把根节点建立出来\n        TreeNode root = new TreeNode(preorder[preorder_root]);\n        // 得到左子树中的节点数目\n        int size_left_subtree = inorder_root - inorder_left;\n        // 递归地构造左子树，并连接到根节点\n        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素\n        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);\n        // 递归地构造右子树，并连接到根节点\n        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素\n        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);\n        return root;\n    }\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int n = preorder.length;\n        // 构造哈希映射，帮助我们快速定位根节点\n        indexMap = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n; i++) {\n            indexMap.put(inorder[i], i);\n        }\n        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);\n    }\n}\n\n```\n\n时间：99.96%\n\n与我的方法的改进之处：用hashMap提高了遍历的效率\n\n\n\n\n\n此外，另一个题解：\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder.length == 0){\n            return null;\n        }\n    Map<Integer, Integer> preIndex = new HashMap<>();\n    for (int i = 0; i < preorder.length; i++) {\n        preIndex.put(preorder[i], i);\n    }\n\n    return buildTree(preIndex, inorder, 0, inorder.length - 1);\n\n\n    }\n\n\nprivate TreeNode buildTree(Map<Integer, Integer> preIndex, int[] in, int start, int end) {\n    if (start == end) {\n        return new TreeNode(in[start]);\n    }\n    int indexOfRoot = start;\n    for (int i = start; i <= end; i++) {\n        if (preIndex.get(in[i]) < preIndex.get(in[indexOfRoot])) {\n            indexOfRoot = i;\n        }\n    }\n    TreeNode root = new TreeNode(in[indexOfRoot]);\n    if (start <= indexOfRoot - 1) root.left = buildTree(preIndex, in, start, indexOfRoot - 1);\n    if (indexOfRoot + 1 <= end) root.right = buildTree(preIndex, in, indexOfRoot + 1, end);\n    return root;\n}\n}\n```\n\n时间：5%，效率很低\n\n和上一题题解的区别，传递的不是数组而是hashMap，导致效率大幅下降\n\n\n\n\n\n#### 10. [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n我的解法：for循环遍历nums[i] >num[i+1]\n\n速度：100%，复杂度O(n)\n\n\n\n优解：\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > nums[right]) left = mid + 1;\n            else if (nums[mid] < nums[right]) right = mid;\n            else right = right - 1;\n        }\n        return nums[left];\n    }\n}\n```\n\n思路：由于数据存在一定的规律，显然可以找到效率更高的做法，这一题就可以使用二分法查找，\n\n但难点在于出现重复值时如何处理，本解巧妙之处在于**`right--`**；既可以保证不越界、也可以保证不会丢失最小值，同时，可以缩小求解数组的长度，保证了不会死循环。\n\n虽然for循环遍历也是0ms，100%，但是二分法的时间复杂度为O(logn)，显然要优于遍历的。\n\n#### 11. [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)\n\n我的题解：\n\n\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n == 0){\n            return 0;\n        }\n        else if(n == 1){\n            return 1;\n        }\n        else{\n            return fib(n - 1) + fib(n - 2);\n        }\n\n    }\n}\n```\n\n问题：超时，一旦n较大，递归的方法速度就很慢\n\n题解2：\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n == 0){\n            return 0;\n        }\n        else if(n == 1){\n            return 1;\n        }\n        int first = 0;\n        int second = 1;\n        int third = 1;\n        for(int i = 0;i < n - 1;i++){\n            third = (first + second) % 1000000007;\n            first = second;\n            second = third;\n        }\n        return third;\n\n    }\n}\n```\n\n不递归，也能实现斐波那契的加法，for足够\n\n时间上O(n),0ms，100%\n\n出现的问题：\n\n1. 没看清题目，结果需要模1000000007\n2. 只在最后一次取模，中间没有取模导致超出int范围\n3. 本来中间使用long，但是long范围也不够，所以也会超出范围\n4. 使用long，返回结果时没有类型转换成int，导致类型错误。\n\n\n\n\n\n#### 12. [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)\n\n我的题解：\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        double x2 = x;\n        boolean negative = n < 0;\n        n = negative ? -n : n;\n        if(x == 0 || x == 1){\n            return x ;\n        }\n        if(n == 0){\n            return 1;\n        }\n        for(int i = 0; i < n - 1; i++){\n            x2 = x2 * x;\n        }\n        return negative? 1 / x2 : x2;\n    }\n}\n```\n\n问题：超出时间限制，所以在for循环除可以改进\n\n解法2：\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(x == 0 || x == 1){\n            return x;\n        }\n        boolean negative = n < 0 ? true : false;\n        n = negative ? -n : n;\n        double res = posiPow(x,n);\n        return negative ? 1 / res : res;\n    }\n\n    public double posiPow(double x, int n){\n        if(n == 0){\n            return 1;\n        }\n        else if( n == 1){\n            return x;\n        }\n        if(n % 2 == 0){\n            return posiPow(x, n/2) * posiPow(x, n/2);\n        }\n        else{\n            return posiPow(x,n/2) * posiPow(x, n/2) * x;\n        }\n    }\n}\n```\n\n解决了for循环的问题，但是没有解决超时问题\n\n复杂度从O(n) --> O((logn)2)\n\n思路：posiPow(x, n/2) 不需要求那么多遍\n\n优解：\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(x == 0 || x == 1){\n            return x;\n        }\n        boolean negative = n < 0 ? true : false;\n        n = negative ? -n : n;\n        double res = posiPow(x,n);\n        return negative ? 1 / res : res;\n    }\n\n    public double posiPow(double x, int n){\n        if(n == 0){\n            return 1;\n        }\n        else if( n == 1){\n            return x;\n        }\n        double t = posiPow(x, n/2);\n        if(n % 2 == 0){\n            return  t * t;\n        }\n        else{\n            return t * t * x;\n        }\n    }\n}\n```\n\n时间复杂度O(logn) 0ms 100%\n\n\n\n\n\n#### 13. [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)\n\n\n\n我的题解：\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int count = 0;\n        while(n != 1){\n            count += n % 2;\n            n = n / 2;\n        }\n        count++;\n        return count;\n        \n    }\n}\n```\n\n问题：超时\n\n优解：\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n    int mask = 0x01;\n\n    int res = 0;\n    int t = n;\n    while (t != 0) {\n        if ((t & mask) == 1) {\n            res++;\n        }\n        t = t >>> 1;\n    }\n\n    return res;\n        \n    }\n}\n```\n\n0ms 100%，时间复杂度O(N),N是n的二进制位数\n\n所以两种做法的区别就在于位运算和普通运算的效率上\n\n\n\n\n\n[解析](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/er-jin-zhi-zhong-1de-ge-shu-by-leetcode-50bb1/)\n\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        int ret = 0;\n        while (n != 0) {\n            n &= n - 1;\n            ret++;\n        }\n        return ret;\n    }\n}\n```\n\n这种解法主要是发现了n&(n-1)可以将n的最后一个1变成0，所以复杂度为O(log*n*)\n\n\n\n\n\n#### 14. [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)\n\n我的题解：\n\n```java\nclass Solution {\n    public int[] printNumbers(int n) {\n        int end = (int)Math.pow(10,n) - 1;\n        int[] res = new int[end];\n        for(int i=0;i<end;i++){\n            res[i] = i+1;\n        }\n        return res;\n\n\n    }\n}\n```\n\n直接for循环，0ms，100%\n\n\n\n#### 15. [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        ListNode head2 =head;\n        if(head.val == val){\n            return head.next;\n        }\n        ListNode before = null;\n        while(head.next != null){\n            if(head.val == val){\n                break;\n            }\n            before = head;\n            head = head.next;\n        }\n        before.next = head.next;\n        head.next = null;\n        return head2;\n\n\n    }\n}\n```\n\n0ms 100%\n\n遍历\n\n#### 16. [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)\n\n\n\n我的题解\n\n```java\nclass Solution {\n    public int[] exchange(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left < right){\n            if(nums[left] % 2 == 0 && nums[right] % 2 == 1){\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] = temp;\n                left++;\n                right--;\n            }\n            else if(nums[left] % 2 == 0){\n                right--;\n            }\n            else if(nums[right] % 2 == 1){\n                left++;\n            }\n            else{\n                left++;\n                right--;\n            }\n\n        }\n        return nums;\n\n    }\n}\n```\n\n双指针，如果符合条件就交换；\n\n这里没有保证奇数之间、偶数之间的顺序。如果需要保证，可以采用冒泡排序，或者两次遍历分别取出奇偶数，然后合到一起去\n\n2ms 53.68%\n\n\n\n**改进思路**\n\n1. 位运算比取模的效率要高\n2. 双指针不需要分这么多种情况\n\n改进后代码：\n\n```java\nclass Solution {\n    public int[] exchange(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left < right){\n            while((nums[left] & 1) != 0 && left < right ){\n                left++;\n            }\n            while((nums[right] & 1) != 1 && left < right){\n                right--;\n            }\n            if(left < right){\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] =temp;\n            }\n\n        }\n        return nums;\n\n    }\n}\n```\n\n1ms 100%\n\n一个地方指出：\n\n```java\n            if(left < right){\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] =temp;\n            }\n```\n\n这里判断不判断其实都可以，因为前面两个while有`left <right`这个判断了，所以这里，要么是left不等于right，找到符合条件的两个数，要么left = right，那即便相等，互换也不会有问题。\n\n#### 17. [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)\n\n双指针即可，常见问题，常见思路\n\n题解：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode getKthFromEnd(ListNode head, int k) {\n        if(head.next == null){//没有后继节点，此时按理k只能为1\n            return head;\n        }\n        ListNode left = head;\n        ListNode right = head;\n        for(int i = 0; i < k - 1; i++){\n            right = right.next;\n        }\n        while(right.next != null){\n            left = left.next;\n            right = right.next;\n        }\n        return left;\n\n    }\n}\n```\n\n0ms，100%\n\n\n\n\n\n#### 18. [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)\n\n题解：\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int left = 0;\n        int right = 1;\n        int res = 0;\n        while(right < prices.length){\n            res = Math.max(res,prices[right]-prices[left]);\n            if(prices[right] < prices[left]){\n                left = right;\n            }\n            right++;\n        }\n        return res;\n\n    }\n}\n```\n\n时间：69%\n\n\n\n\n\n#### 19. [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length == 0){\n            int[] res = new int[0];\n            return res;\n        }\n        int[] res = new int[nums.length - k + 1];\n        int max = nums[0];\n        for(int i = 0; i < k; i++){\n            max = Math.max(max,nums[i]);\n        }\n        res[0] = max;\n\n        for(int i = 1;i < nums.length - k + 1; i++){\n            max = nums[i];\n            for(int j = i; j < i + k; j++){\n                max = Math.max(max,nums[j]);\n            }\n            res[i] = max;\n\n        }\n\n        return res;\n\n    }\n}\n```\n\n通过了但显然效率不高（22%），复杂度O(nk)\n\n改进思路，如何将查询最大值复杂度降低，最好能从O(k)降低到O(1)\n\n可选方法：单调队列\n\n[解析](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/)\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length == 0 || k == 0){\n            return new int[0];\n        }\n        Deque<Integer> deque = new LinkedList<>();\n        int[] result = new int[nums.length - k + 1];\n\n        for(int j = 0, i = 1 - k; j < nums.length; i++, j++){\n            //如果不在窗口内删掉第一个\n            if(i > 0 && deque.peekFirst() == nums[i-1]){\n                deque.removeFirst();\n            }\n            //保持递减\n            while(!deque.isEmpty() && deque.peekLast() < nums[j]){\n                deque.removeLast();\n            }\n            deque.addLast(nums[j]);\n\n            //记录最大值\n            if(i >= 0){\n                result[i] = deque.peekFirst();\n            }\n        }\n        return result;\n\n    }\n}\n```\n\n效率：78.2%\n\n使用单调队列获得窗口内的最大值，复杂度O(nlogn)，不可能同时在添加删除和获得最大值时实现O(1)复杂度。\n\n注意一点，队列为非严格递减队列，`deque.peekLast() < nums[j])` 此处是将小于滑动窗口右边的值的数去掉，而非把小于等于去掉，所以此处形成的队列是非严格递减的。\n\n\n\n\n\n#### 20. [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)\n\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int res,k;\n    public int kthLargest(TreeNode root, int k) {\n        this.k = k;\n        dsf(root);\n        return res;\n\n\n    }\n\n    public void dsf(TreeNode node){\n        if(node == null){\n            return;\n        }\n        dsf(node.right);\n        k--;\n        if(k == 0){\n            this.res = node.val;\n            return;\n        }\n        dsf(node.left);\n\n\n    }\n\n}\n```\n\n思路：二叉搜索树的中序遍历为递增序列，所以中旬遍历倒序为递减序列，记录一个公共变量k，然后中旬倒序遍历，当k为0时，该节点的val值就是所要求的的值。\n\nTips：如何保存公共变量是一个需要注意的问题，java对于数值是直接复制值，所以如果传递int值每次递归实际上访问的不是用一个数值，此处使用类的变量是一个解决方法，如果题目是直接给定一个函数没有这个类的话，我们可以定义一个只有1个变量的数组，用传递数组的方式来实现传递引用。\n\n[更多详细解析](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/)\n\n\n\n#### 21. [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n\n思路分析：\n\n显然在排序树组中查找一个数值的复杂度不会超过O(n)，同时不会低于O(logn)，直接遍历是一个可以解决问题的方法，所以我们应该尽可能地使复杂度靠近O(logn).\n\n因此，思路显然为：二分查找找到首尾两个值，然后利用下标差得到该数字的个数\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums.length == 0){\n            return 0;\n        }\n        int left = binarySearch(nums, 0, nums.length - 1, target, 0);\n        if(left == -1){\n            return 0;\n        }\n        int right = binarySearch(nums, 0, nums.length - 1, target, 1);\n        return right - left + 1;\n\n    }\n\n    //flag为0表示查找左边target，1表示查找右边target\n    public int binarySearch(int[] nums, int left, int right,int target, int flag){\n        int middle = (left + right) / 2;\n        if(target < nums[left]){\n            return -1;\n        }\n        if(target > nums[right]){\n            return -1;\n        }\n        if(left == right && nums[left] == target){\n            return left;\n        }\n        else if(left == right){\n            return -1;\n        }\n        if(target < nums[middle]){\n            return binarySearch(nums, left, middle - 1, target, flag);\n        }\n        else if(nums[middle] < target){\n            return binarySearch(nums, middle + 1, right, target, flag);\n        }\n        else{\n            if(flag == 0){//查找左边target\n                if(middle > left && nums[middle - 1] == target){\n                    return binarySearch(nums, left, middle - 1, target, flag);\n                }\n                else{\n                    return middle;\n                }\n\n            }\n            else{//查找右边target\n                if(middle < right && nums[middle + 1] == target){\n                    return binarySearch(nums, middle + 1, right, target, flag);\n                }\n                else{\n                    return middle;\n                }\n\n            }\n        }\n    }\n\n}\n```\n\n0ms，100%\n\n出现的问题：\n\n1. 误以为target一定在数组中，导致出错\n2. if-else太多\n3. 查左边和查右边的代码重复的较多，可以合并\n\n[**官方题解：**](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-wl6kr/)\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int leftIdx = binarySearch(nums, target, true);\n        int rightIdx = binarySearch(nums, target, false) - 1;\n        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {\n            return rightIdx - leftIdx + 1;\n        } \n        return 0;\n    }\n\n    public int binarySearch(int[] nums, int target, boolean lower) {\n        int left = 0, right = nums.length - 1, ans = nums.length;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n两种做法的异同：总的思路一致，二分查找实现的方法不同，对于第一种，为了避免陷入死循环，就必须判断很多特殊情况，导致if-else结构很多，同时，很多相同的if-else结构可以合并，但第一种返回的就是target的下标，否则返回-1，而第二种实际上返回的是最接近target的数的下标，将特殊情况抛给二分法之外判断。\n\n\n\n\n\n优解：\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        return helper(nums, target) - helper(nums, target - 1);\n    }\n    int helper(int[] nums, int tar) {\n        int i = 0, j = nums.length - 1;\n        while(i <= j) {\n            int m = (i + j) / 2;\n            if(nums[m] <= tar) i = m + 1;\n            else j = m - 1;\n        }\n        return i;\n    }\n}\n```\n\n思路：不是求target的左右边界，而是求target和target-1的右边界相减\n\n此外，这个算法求出来的不是target的最右边的值的下标，而是上述下标+1，这样其实可以避免一些相等时的特殊情况的判断。\n\n\n\n#### 22. [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)\n\n看到题目的一个思路：双向栈，将字母入栈，如果有重复字母，出栈至 去掉重复的那一个，max = max（max，length）\n\n问题：字母是无序的，每次都要重复判断，且栈内内容不好判断。\n\n\n\n优解：\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s == null || s.length() == 0){\n            return 0;\n        }\n\n        HashMap<Character, Integer> map = new HashMap<>();\n        char[] chars = s.toCharArray();\n\n        int res = 0, start = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(map.containsKey(chars[i])){\n                start = Math.max(map.put(chars[i], i) + 1, start);\n            }\n            map.put(chars[i], i);\n            res = Math.max(res, i - start + 1);\n        }\n        return res;\n\n    }\n}\n```\n\n利用hashMap来实现不重复，类似之前的复制随机指针链表\n\ntips：hashMap函数的put方法如果重复了会返回value，否则返回null\n\n4ms，92.01%\n\ntodo：动态规划&滑动窗口也可解\n\n[动态规划](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/)可解，但是并没有简单很多，时间复杂度一致\n\n\n\n#### 23. [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)\n\n思路：动态规划题，往右或往下移动，所以为了取得最大值，最后一次一定是右下角的值，开始时左上角的值。假设M（i,j）是坐标（i,j）到右下角的礼物的最大值，所以D(i, j)是(i, j)坐标处的最大值，所以M（i, j）=  D(i, j) + max(M(i+1, j), M(i, j+1))\n\n```java\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;//提示中说明存在且不为零\n        int[][] res = new int[m][n];\n        res[m - 1][n - 1] = grid[m - 1][n- 1];\n        for(int i = m - 1; i >= 0; i--){\n            for(int j = n - 1; j >= 0; j--){\n                if(j == n - 1 && i == m -1){\n                    continue;\n                }\n                else if(j == n - 1){\n                    res[i][j] = res[i + 1][j] + grid[i][j];\n                }\n                else if(i == m -1){\n                    res[i][j] = res[i][j + 1] + grid[i][j];\n                }\n                else{\n                    res[i][j] = Math.max(res[i][ j + 1], res[i + 1][j]) + grid[i][j];\n                }\n            }\n        }\n        return res[0][0];\n    }\n}\n```\n\nproblems:\n\n1. 最低级的错误是，将（i，j）坐标的值写成res[i,j]\n\n效率：3ms，27.79%\n\n几乎同样的思路\n\n```java\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(i == 0 && j == 0) continue;\n                if(i == 0) grid[i][j] += grid[i][j - 1] ;\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\n                else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);\n            }\n        }\n        return grid[m - 1][n - 1];\n    }\n}\n```\n\n2ms，效率98%\n\n我的代码修改为\n\n```java\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;//提示中说明存在且不为零\n        for(int i = m - 1; i >= 0; i--){\n            for(int j = n - 1; j >= 0; j--){\n                if(j == n - 1 && i == m -1){\n                    continue;\n                }\n                else if(j == n - 1){\n                    grid[i][j] += grid[i + 1][j];\n                }\n                else if(i == m -1){\n                    grid[i][j] += grid[i][j + 1];\n                }\n                else{\n                    grid[i][j] += Math.max(grid[i][ j + 1], grid[i + 1][j]);\n                }\n            }\n        }\n        return grid[0][0];\n    }\n}\n```\n\n仍然是3ms！！\n\n**！！！！！**\n\n是否是for循环++和--的区别？\n\n单独跑了一下，差别不明显，时大时小，忽略这个情况；\n\n#### 24. [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)\n\n思路：也是动态规划，假设到第i个字母的翻译方法有D(i)种，那么D(i+1) = D(i) + D(i - 1)(当第i-1和第i个字母组成的数小数等于25时)，否则D(i+1) = D(i)\n\n```java\nclass Solution {\n    public int translateNum(int num) {\n        int length = String.valueOf(num).length();\n        int[] nums = new int[length];\n        int[] res = new int[length];\n        for(int i = length - 1; i >= 0; i--){\n            nums[i] = num % 10;\n            num = num / 10;\n        }\n        for(int i = 0; i < length; i++){\n            if( i == 0){\n                res[i] = 1;\n            }\n            else if(nums[i - 1] * 10 + nums[i] <=25 && nums[i - 1] != 0){\n                res[i] = res[i - 1] + (i > 1 ? res[i - 2] : 1);\n            }\n            else{\n                res[i] = res[i-1];\n            }\n        }\n        return res[length - 1];\n\n    }\n}\n```\n\n问题：\n\n1. 06只有1种翻译方法\n2. 数组不要越界\n\n0ms，100%\n\n#### 25. [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)\n\n思路：求出这个数，然后得出对应位数的数字\n\n```java\nclass Solution {\n    public int findNthDigit(int n) {\n        int maxIndex = 9;\n        if(n <= 9){\n            return n;\n        }\n        int[] nums = new int[maxIndex];\n        nums[0] = 0;\n        for(int i=1;i<maxIndex;i++){\n            nums[i] = i * (int)Math.pow(10,i - 1) * 9 + nums[i - 1];\n        }\n        int right = 0;\n        for(int i=0;i<maxIndex;i++){\n            if(nums[right] < n){\n                right++;\n            }\n        }\n        int temp = n - nums[right - 1];\n        int reminder = temp % right;\n        int quotient = temp / right;\n        if(reminder == 0){\n            reminder = right;\n            quotient--;\n        }\n\n        int res = (int)Math.pow(10,right - 1) + quotient;\n        return Integer.parseInt(\"\" + String.valueOf(res).charAt(reminder - 1));\n\n    }\n}\n```\n\n0ms 100%（时而1ms）\n\n待优化地方：\n\n1. `Integer.parseInt(\"\" + String.valueOf(res).charAt(reminder - 1));`\n\n可以优化为`String.valueOf(res).charAt(reminder - 1) - ‘0’`\n\n2. 求n是几位数的某一位时复杂了，可以简单的\n\n\n\n简化后的代码\n\n```java\nclass Solution {\n    public int findNthDigit(int n) {\n        if(n <= 9){\n            return n;\n        }\n        long r = 1, count = 9;\n        int right = 1;\n        while(n > count){\n            right++;\n            n -= count;\n            r = 10 * r;\n            count = right * r * 9;\n        }\n        int reminder = (n-1) % right;\n        int quotient = (n-1) / right;\n        long res = r + quotient;\n        return String.valueOf(res).charAt(reminder) - '0';\n    }\n}\n```\n\n100%\n\n#### 26. [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)\n\n思路：插入时排序，然后维护两个指针表示中位数，\n\n代码：\n\n```java\nclass MedianFinder {\n\n    /** initialize your data structure here. */\n    int size;\n    int left;\n    int right;\n    ArrayList<Integer> nums;\n    public MedianFinder() {\n        size = 0;\n        left = -1;\n        right = -1;\n        nums = new ArrayList<>();\n    }\n\n    public void addNum(int num) {\n        if(size == 0){\n            left++;\n            right++;\n            size++;\n            nums.add(num);\n            return;\n        }\n        else if(left == right){\n            right++;\n        }\n        else{\n            left++;\n        }\n        int a = 0, b = size - 1;\n        size++;\n        if(num >= nums.get(b)){\n            nums.add(num);\n            return;\n        }\n        else if(num <= nums.get(a)){\n            nums.add(0,num);\n            return;\n        }\n        while(a < b){\n            int middle = (a + b) / 2;\n            if(nums.get(middle) < num ){\n                a = middle + 1;\n            }\n            else if(nums.get(middle) > num){\n                b = middle - 1;\n            }\n            else{\n                b = middle;\n                a = middle;\n                break;\n            }\n        }\n        if(num > nums.get(b)){\n            nums.add(b + 1, num);\n        }\n        else{\n            nums.add(b , num);\n        }\n    }\n\n    public double findMedian() {\n        if(left == -1 && right == -1){\n            return 0;\n        }\n        else{\n            return 1.0 * (nums.get(left) + nums.get(right)) / 2;\n        }\n\n    }\n}\n```\n\n108ms ，13.81%\n\n问题：二分法求解当数组中不存在时只能说是在该数附近，所以左右两边都要比较\n\n\n\n优化解法：（使用优先队列）\n\n```java\nclass MedianFinder {\n    Queue<Integer> A,B;\n    public MedianFinder() {\n        A = new PriorityQueue<Integer>();\n        B = new PriorityQueue<Integer>((x,y) -> (y - x));\n\n    }\n    public void addNum(int num) {\n        if(A.size() == B.size()){\n            B.add(num);\n            A.add(B.poll());\n        }\n        else{\n            A.add(num);\n            B.add(A.poll());\n        }\n\n    }\n    public double findMedian() {\n        if(A.size() == B.size()){\n            return (A.peek() + B.peek()) / 2.0;\n        }\n        else{\n            return A.peek();\n        }\n    }\n}\n\n```\n\n63ms 91%\n\n使用一个大顶堆和一个小顶堆来分别存储较大的数和较小的数，中位数就是某一个堆堆顶的数或者两个堆堆顶数的平均数；\n\nQuestion：如何确定插入的数应该放在A还是B？\n\n1. 先定义规则m=n的时候插入A，此时先将数字插入另一个堆中，然后将堆顶的数字弹出（此时已排序）加入到A中。同理，插入B的时候先插入A\n\n\n\n","tags":["刷题","力扣"],"categories":["刷题"]},{"title":"利用github与hexo搭建个人博客网站","url":"/2023/03/19/利用github与hexo搭建个人博客网站/","content":"\n本文主要介绍如何通过github和hexo框架，不购买服务器资源实现部署个人博客\n\n<!--more-->\n\n\n\n## 一、安装nodejs\n\n可在git命令行通过以下命令检查本地是否安装了nodejs和npm\n\n```bash\n$ node -v\n$ npm -v\n```\n\n出现以下内容说明已安装，如果未安装，可以通过[官网](https://nodejs.org/en/) 提供的安装工具自行安装。\n\n![image-20230224231949776](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224231949776.png)\n\n\n\n## 二、安装和初始化hexo\n\n1. 使用如下命令安装hexo\n\n```bash\n$ npm install hexo-cli -g\n```\n\n（如果npm速度较慢可以换国内源）\n\n2. 初始化hexo\n\n```bash\n$ hexo init\n$ npm install\n```\n\n3. 本地运行\n\n```bash\n$ hexo clean\n$ hexo g\n$ hexo s\n```\n\n如果出现提示`ERROR Try running: 'rm -rf node_modules && npm install --force'`，运行该命令，运行完成后重新运行上述命令\n\n出现以下结果，表示运行正常，可在浏览器中访问给定网址，按\"ctrl+c\"可停止本地运行\n\n![image-20230224233040783](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224233040783.png)\n\n页面内容如下\n\n![image-20230224233353905](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224233353905.png)\n\n\n\n## 三、创建github仓库并上传代码\n\n1. 登录[github](github.com), 点击右上角\"+\"，选择\"new repository\"，按如下内容创建仓库\n\n![image-20230224233938038](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224233938038.png)\n\n2. 安装hexo-deployer-git\n\n   ```bash\n   $ npm install hexo-deployer-git --save\n   ```\n   \n\n   \n3. 修改本地hexo目录下_config.yml文件，将最底下\n\n   ```\n   deploy:\n     type: ''\n   ```\n\n   修改为\n\n   ```yaml\n   deploy:\n     type:git\n     repository:https://github.com/freezer712/freezer712.github.io.git\n     branch:main\n   ```\n\n   \n\n4. 创建仓库后，在本地hexo目录下用git命令行执行以下命令上传代码（如果未配置ssh可使用personal access token来push代码，获取流程可参考<a id=\"token\">[token获取方法](#token)</a> \n\n```\n#初始化本地仓库\ngit init\n#添加远程git地址，jevonk是我的gitlab用户名\ngit remote add origin https://github.com/freezer712/freezer712.github.io.git\n#添加需要管理文件\ngit add .\n#提交内容\ngit commit  -m \"init\"\n#修改默认分支名master为main\ngit branch -m master main\n#强行推送到远程, 注意可能遇到主分支是受保护的，无法推送。自行百度处理\ngit push -f origin main\n\n```\n\n（使用token时）弹出下面界面可直接cancel\n\n![image-20230225000325295](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230225000325295.png)\n\n依次弹出如下页面，输入github网站用户名和**token**\n\n![image-20230225000454714](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230225000454714.png)\n\n![image-20230225000444761](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230225000444761.png)\n\n出现下图内容表示代码已经push到github仓库\n\n![image-20230225001057788](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230225001057788.png)\n\n![image-20230225001133409](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230225001133409.png)\n\n\n\n## 四、在本地写博客并发布\n\n1. 创建博客\n\n```bash\n#该命令会创建一片名为\"first blog\"的博客，在/source/_posts目录下生成一个\"first-blog.md\"文件，可以将已写好博客替换进去\n$ hexo new \"first blog\"\n\n```\n\n2. 生成静态文件\n\n   ```bash\n   #清理缓存文件，是一个比较常用的命令\n   $ hexo clean\n   # 重新生成文件\n   $ hexo g\n   ```\n\n3. 本地运行(访问http://localhost:4000/， 使用Ctrl+C关闭)\n\n   ```bash\n   #本地运行查看效果\n   $ hexo s\n   ```\n\n4. 上传\n\n   ```bash\n   # 上传\n   $ hexo d\n   ```\n\n\n\n\n\n\n\n\n\n## Utils\n\n\n\n<a id=\"token\">token获取方法</a>\n\n1. github网站点击右上角头像，点击settings\n\n![image-20230224235114197](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224235114197.png)\n\n2. 左边栏最底下点击\"Developer settings\"， 点击\"Personal access tokens\",，点击\"Tokens(classic)\", 页面右上部点击\"Generate new token\", \"Generate new token(classic)\",按下图填入信息![image-20230224235628699](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224235628699.png)\n\n点击\"generate token\"，即可获取token（请注意保存，不会再显示）\n\n![image-20230224235844994](https://freezer712.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20230224235844994.png)\n\n[点我快速返回！](#token_back)","tags":["github","hexo"],"categories":["建站"]},{"title":"Hello","url":"/2023/03/19/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"categories","url":"/categories/index.html","content":"\n---\n\n"},{"title":"reading","url":"/reading/index.html"},{"title":"tags","url":"/tags/index.html"}]